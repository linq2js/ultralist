{"version":3,"sources":["../index.js"],"names":["arrayMethods","split","cloneMethod","Symbol","create","items","subLists","list","subscribers","filters","orders","mappers","clearListCache","Object","keys","forEach","listName","processedItems","orderedItems","length","dispatch","subscriber","modifyItems","callback","__immutable","newItems","slice","createCopy","doFilter","filter","Error","x","item","doSort","order","sort","a","b","index","o","getter","by","aValue","bValue","desc","meta","assign","__chainable","reduce","prototype","method","args","result","listResult","push","subListName","undefined","predicate","updater","count","updatedItems","map","value","includeSubscribers","arguments","splice","removedItems","options","type","name","Function","Array","includeMeta","subList","indexOf","feature","indexedItems","filteredItems","mapper","extra","extraData"],"mappings":"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","file":"index.js","sourcesContent":["const arrayMethods = 'push pop shift unshift splice slice indexOf find findIndex toString map'.split(\r\n  /\\s+/\r\n);\r\nconst cloneMethod = Symbol('clone');\r\n\r\nexport default function create(...items) {\r\n  let subLists = {};\r\n  let list;\r\n  let subscribers = [];\r\n  const filters = {};\r\n  const orders = {};\r\n  const mappers = {};\r\n\r\n  function clearListCache() {\r\n    Object.keys(subLists).forEach(listName => {\r\n      delete subLists[listName].processedItems;\r\n      delete subLists[listName].orderedItems;\r\n    });\r\n    list.length = items.length;\r\n  }\r\n\r\n  function dispatch() {\r\n    subscribers.forEach(subscriber => subscriber(items));\r\n  }\r\n\r\n  function modifyItems(callback) {\r\n    if (list.__immutable) {\r\n      const newItems = items.slice();\r\n      callback(newItems);\r\n      return createCopy(newItems);\r\n    }\r\n    clearListCache();\r\n    callback(items);\r\n    list.length = items.length;\r\n    dispatch();\r\n    return list;\r\n  }\r\n\r\n  function doFilter(filter, items) {\r\n    if (typeof filter === 'string') {\r\n      filter = filters[filter];\r\n\r\n      if (!filter) {\r\n        throw new Error(`Filter named ${filter} cannot be found`);\r\n      }\r\n    }\r\n\r\n    return items.filter(x => filter(x.item));\r\n  }\r\n\r\n  function doSort(order, items) {\r\n    if (typeof order === 'string') {\r\n      order = orders[order];\r\n\r\n      if (!order) {\r\n        throw new Error(`Order named ${order} cannot be found`);\r\n      }\r\n    }\r\n\r\n    return items.slice().sort((a, b) => {\r\n      for (let index = 0; index < order.length; index++) {\r\n        const o = order[index];\r\n        const getter = o.by;\r\n        const aValue = getter(a.item);\r\n        const bValue = getter(b.item);\r\n        if (aValue > bValue) return o.desc ? -1 : 1;\r\n        if (aValue < bValue) return o.desc ? 1 : -1;\r\n      }\r\n      return 0;\r\n    });\r\n  }\r\n\r\n  function createCopy(newItems, meta = {}) {\r\n    return create(...newItems)[cloneMethod](\r\n      Object.assign(\r\n        {\r\n          subscribers,\r\n          filters,\r\n          mappers,\r\n          orders,\r\n          subLists,\r\n          __chainable: list.__chainable,\r\n          __immutable: list.__immutable\r\n        },\r\n        meta\r\n      )\r\n    );\r\n  }\r\n\r\n  return (list = Object.assign(\r\n    arrayMethods.reduce((prototype, method) => {\r\n      prototype[method] = function(...args) {\r\n        let result;\r\n        const listResult = modifyItems(\r\n          items => (result = items[method](...args))\r\n        );\r\n        if (list.__chainable || method === 'push' || method === 'unshift')\r\n          return listResult;\r\n        return result;\r\n      };\r\n      return prototype;\r\n    }, {}),\r\n    {\r\n      length: items.length,\r\n      [cloneMethod](meta) {\r\n        subscribers.push(...meta.subscribers);\r\n        Object.assign(filters, meta.filters);\r\n        Object.assign(orders, meta.orders);\r\n        Object.assign(mappers, meta.mappers);\r\n        Object.keys(meta.subLists).forEach(subListName => {\r\n          subLists[subListName] = Object.assign(\r\n            {\r\n              processedItems: undefined,\r\n              orderedItems: undefined\r\n            },\r\n            meta.subLists[subListName]\r\n          );\r\n        });\r\n        list.__chainable = meta.__chainable;\r\n        list.__immutable = meta.__immutable;\r\n        return list;\r\n      },\r\n      /**\r\n       * update all items which is satisfied predicate\r\n       */\r\n      update(predicate, updater, count = 0) {\r\n        let updatedItems = 0;\r\n        const newItems = items.map((item, index) => {\r\n          if (count && updatedItems >= count) return item;\r\n          if (predicate(item)) {\r\n            updatedItems++;\r\n            return updater(item, index);\r\n          }\r\n          return item;\r\n        });\r\n        if (updatedItems) {\r\n          if (list.__immutable) {\r\n            return createCopy(newItems);\r\n          }\r\n\r\n          items = newItems;\r\n          clearListCache();\r\n          dispatch();\r\n        }\r\n\r\n        return list;\r\n      },\r\n      /**\r\n       * subscribe changed event\r\n       */\r\n      subscribe(subscriber) {\r\n        subscribers.push(subscriber);\r\n        return list.__chainable\r\n          ? list\r\n          : () => (subscribers = subscribers.filter(x => x !== subscriber));\r\n      },\r\n      /**\r\n       * make the list is chainable\r\n       */\r\n      chainable(value = true) {\r\n        if (list.__chainable === value) return list;\r\n        return createCopy(items, {\r\n          __chainable: value\r\n        });\r\n      },\r\n      /**\r\n       * make the list is immutable\r\n       */\r\n      immuatable(value = true) {\r\n        if (list.__immutable === value) return list;\r\n        return createCopy(items, { __immutable: value });\r\n      },\r\n      /**\r\n       * clone list\r\n       */\r\n      clone(includeSubscribers) {\r\n        if (includeSubscribers) {\r\n          return createCopy(items);\r\n        }\r\n        return createCopy(items, {\r\n          subscribers: []\r\n        });\r\n      },\r\n      /**\r\n       * get original items\r\n       */\r\n      items() {\r\n        return items;\r\n      },\r\n      /**\r\n       * get/set item by its index\r\n       */\r\n      item(index, value) {\r\n        if (arguments.length === 1) return items[index];\r\n        return modifyItems(items => (items[index] = value));\r\n      },\r\n      removeAll() {\r\n        items.splice(0, items.length);\r\n        dispatch();\r\n        return list;\r\n      },\r\n      /**\r\n       * remove items which is satisfied predicate\r\n       */\r\n      remove(predicate, count = 0) {\r\n        let removedItems = 0;\r\n        const newItems = items.filter(item => {\r\n          if (count && removedItems >= count) return true;\r\n          if (predicate(item)) {\r\n            removedItems++;\r\n            return false;\r\n          }\r\n          return true;\r\n        });\r\n        if (removedItems) {\r\n          if (list.__immutable) {\r\n            return createCopy(newItems);\r\n          }\r\n\r\n          items = newItems;\r\n          clearListCache();\r\n          dispatch();\r\n        }\r\n\r\n        return list;\r\n      },\r\n      /**\r\n       * define sub list with specified options: { filter, order }\r\n       */\r\n      define(listName, options = {}) {\r\n        const [type, name] = listName.split(':');\r\n        if (name) {\r\n          switch (type) {\r\n            case 'order':\r\n              if (options instanceof Function) {\r\n                options = { by: options };\r\n              }\r\n              if (!(options instanceof Array)) {\r\n                options = [options];\r\n              }\r\n\r\n              orders[name] = options;\r\n              break;\r\n            case 'filter':\r\n              filters[name] = options;\r\n              break;\r\n            case 'map':\r\n              mappers[name] = options;\r\n              break;\r\n            default:\r\n              throw new Error(`Unsupported option ${type}`);\r\n          }\r\n        } else {\r\n          let { filter, order, map } = options;\r\n          if (order && !(order instanceof Array) && typeof order !== 'string') {\r\n            order = [order];\r\n          }\r\n          subLists[listName] = { filter, order, map };\r\n        }\r\n\r\n        return list;\r\n      },\r\n      /**\r\n       * get sub list\r\n       * @listName string name defined sub list\r\n       * @includeMeta boolean returns array that contains item and its metadata { order: number, item: object, index: number } if true unless returns filtered and sorted items\r\n       */\r\n      get(listName = 'default', includeMeta = false) {\r\n        let subList = subLists[listName];\r\n        if (!subList) {\r\n          // create default list with no filter and no order\r\n          subLists[listName] = subList = {};\r\n          // list name can be combination of predefined filter/order names\r\n          if (listName.indexOf(':') !== -1) {\r\n            // parse feature list which is separated by spacings\r\n            listName.split(/\\s+/).forEach(feature => {\r\n              // featureType:featureName\r\n              const [type, name] = feature.split(/:/);\r\n              if (!name) {\r\n                // is sub list name, copy all props of referenced sub list to current\r\n                Object.assign(subList, subLists[type]);\r\n              } else {\r\n                subList[type] = name;\r\n              }\r\n            });\r\n          }\r\n        }\r\n\r\n        if (!subList.processedItems) {\r\n          const indexedItems = items.map((item, index) => ({ index, item }));\r\n          const filteredItems = subList.filter\r\n            ? doFilter(subList.filter, indexedItems)\r\n            : indexedItems;\r\n          const orderedItems = subList.order\r\n            ? doSort(subList.order, filteredItems)\r\n            : filteredItems;\r\n\r\n          orderedItems.forEach((x, index) => (x.order = index));\r\n\r\n          const mapper = subList.map\r\n            ? subList.map instanceof Function\r\n              ? subList.map\r\n              : mappers[subList.map]\r\n            : undefined;\r\n          subList.processedItems = mapper\r\n            ? filteredItems.map(mapper)\r\n            : filteredItems;\r\n          subList.orderedItems = orderedItems.map(\r\n            (x, ...args) => (mapper ? mapper(x.item, ...args) : x.item)\r\n          );\r\n\r\n          if (subList.extra) {\r\n            subList.extraData =\r\n              subList.extra(subList.processedItems, subList.orderedItems) || {};\r\n          }\r\n        }\r\n\r\n        if (typeof includeMeta === 'string')\r\n          return subList.extraData[includeMeta];\r\n\r\n        return includeMeta ? subList.processedItems : subList.orderedItems;\r\n      }\r\n    }\r\n  ));\r\n}\r\n"]}